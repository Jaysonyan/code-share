{"ast":null,"code":"import { binarySearchText } from \"./utils\";\n\nclass TextDocument {\n  constructor() {\n    this.text = [[]];\n  }\n\n  getString() {\n    console.log(text);\n    let some = this.text.map(line => line.map(char => char.val).concat(\"\")).concat(\"\");\n    console.log(some);\n    return some;\n  }\n\n  getChar(row, column) {\n    return this.text[row][column];\n  }\n\n  insertChar(character) {\n    let _this$getPosOfChar = this.getPosOfChar(character),\n        row = _this$getPosOfChar.row,\n        column = _this$getPosOfChar.column;\n\n    if (character.value === '\\n') {\n      let newLine = this.text[row].splice(column);\n      this.text.splice(row, 0, newLine);\n    }\n\n    this.text[row].splice(column, 0, character);\n  }\n\n  deleteChars(startPos, endPos) {\n    let rowDiff = Math.max(0, endPos.row - startPos.row - 1);\n    this.text.splice(startPos + 1, rowDiff);\n\n    if (startPos.row === endPos.row) {\n      let colDiff = startPos.column - endPos.column;\n      this.text.splice(startPos.column, colDiff);\n    } else {\n      this.text.splice(startPos.column);\n      this.text.splice(0, endPos.column);\n    }\n  }\n\n  deleteChar(character) {\n    let _this$getPosOfChar2 = this.getPosOfChar(character),\n        row = _this$getPosOfChar2.row,\n        column = _this$getPosOfChar2.column;\n\n    if (character.value === '\\n') {\n      let nextLine = this.text[row + 1];\n      this.text.splice(row + 1, 1);\n      this.text[row] = this.text[row].concat(nextLine);\n    }\n\n    this.text[row].splice(column, 1);\n  }\n\n  getLeftChar(row, column) {\n    console.log(row);\n\n    if (row === 0 && column === 0) {\n      return [];\n    }\n\n    row -= column === 0 ? 1 : 0;\n    return this.text[row][column];\n  }\n\n  getRightChar(row, column) {\n    let numRows = this.text.length;\n    let numCols = this.text[row].length;\n\n    if (row >= numRows - 1) {\n      //created a newline at EOF\n      return [];\n    } else if (column === numCols) {\n      //if inserted char is at EOL\n      if (row === numRows) {\n        return [];\n      } else {\n        row += 1;\n        column = 0;\n      }\n    }\n\n    return this.text[row][column].relativeIndex;\n  }\n\n  getPosOfChar(char) {\n    let row = binarySearchText(this.text, char, (arrayVal, val) => {\n      if (arrayVal.length === 0) {\n        return 0;\n      }\n\n      return arrayVal[0].greaterThan(char) ? 1 : arrayVal[arrayVal.length - 1].greaterThan(char) ? -1 : 0;\n    });\n    let column = binarySearchText(this.text[row], char, (arrayVal, val) => arrayVal.equalTo(val) ? 0 : arrayVal.greaterThan(val) ? 1 : -1);\n    return {\n      row,\n      column\n    };\n  }\n\n}\n\nexport default TextDocument;","map":{"version":3,"sources":["/Users/Jayson/Desktop/code-share/client/src/components/textdocument.js"],"names":["binarySearchText","TextDocument","constructor","text","getString","console","log","some","map","line","char","val","concat","getChar","row","column","insertChar","character","getPosOfChar","value","newLine","splice","deleteChars","startPos","endPos","rowDiff","Math","max","colDiff","deleteChar","nextLine","getLeftChar","getRightChar","numRows","length","numCols","relativeIndex","arrayVal","greaterThan","equalTo"],"mappings":"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","sourcesContent":["import { binarySearchText } from \"./utils\"\n\nclass TextDocument {\n\n  constructor() {\n    this.text = [[]]\n  }\n\n  getString() {\n    console.log(text)\n    let some = this.text.map(line => line.map(char => char.val).concat(\"\")).concat(\"\")\n    console.log(some)\n    return some\n  }\n\n  getChar(row, column) {\n    return this.text[row][column]\n  }\n\n  insertChar(character) {\n    let { row, column } = this.getPosOfChar(character)\n    if (character.value === '\\n') {\n      let newLine = this.text[row].splice(column)\n      this.text.splice(row, 0, newLine)\n    }\n    this.text[row].splice(column, 0, character)\n  }\n\n  deleteChars(startPos, endPos) {\n    let rowDiff = Math.max(0, endPos.row - startPos.row - 1)\n    this.text.splice(startPos + 1, rowDiff)\n    if (startPos.row === endPos.row) {\n      let colDiff = startPos.column - endPos.column\n      this.text.splice(startPos.column, colDiff)\n    } else {\n      this.text.splice(startPos.column)\n      this.text.splice(0, endPos.column)\n    }\n  }\n\n  deleteChar(character) {\n    let { row, column } = this.getPosOfChar(character)\n    if (character.value === '\\n') {\n      let nextLine = this.text[row+1]\n      this.text.splice(row+1, 1)\n      this.text[row] = this.text[row].concat(nextLine)\n    }\n    this.text[row].splice(column, 1)\n  }\n\n  getLeftChar(row, column) {\n    console.log(row)\n    if (row === 0 && column === 0) {\n      return []\n    }\n    row -= column === 0 ? 1 : 0\n    return this.text[row][column]\n  }\n\n  getRightChar(row, column) {\n    let numRows = this.text.length\n    let numCols = this.text[row].length\n    if (row >= numRows-1) { //created a newline at EOF\n      return []\n    } else if (column === numCols) { //if inserted char is at EOL\n      if (row === numRows) {\n        return []\n      } else {\n        row += 1\n        column = 0\n      }\n    }\n    return this.text[row][column].relativeIndex\n  }\n\n  getPosOfChar(char) {\n    let row = binarySearchText(this.text, char, (arrayVal, val) => {\n      if (arrayVal.length === 0) {\n        return 0\n      }\n      return arrayVal[0].greaterThan(char) ? 1 : arrayVal[arrayVal.length-1].greaterThan(char) ? -1 : 0\n    })\n    let column = binarySearchText(this.text[row], char, (arrayVal, val) => (\n      arrayVal.equalTo(val) ? 0 : arrayVal.greaterThan(val) ? 1 : -1\n    ))\n    return { row, column }\n  }\n}\n\nexport default TextDocument\n"]},"metadata":{},"sourceType":"module"}