{"ast":null,"code":"import { binarySearchText } from \"./utils\";\n\nclass TextDocument {\n  constructor() {\n    this.text = [[]];\n  }\n\n  getString() {\n    return this.text.map(line => line.map(char => char.value).join(\"\")).join(\"\");\n  }\n\n  getChar(row, column) {\n    return this.text[row][column];\n  }\n\n  insertChar(character) {\n    let _this$getPosOfChar = this.getPosOfChar(character),\n        row = _this$getPosOfChar.row,\n        column = _this$getPosOfChar.column;\n\n    if (character.value === '\\n') {\n      let newLine = this.text[row].splice(column);\n      this.text.splice(row, 0, newLine);\n    }\n\n    this.text[row].splice(column, 0, character);\n  }\n\n  deleteChars(startPos, endPos) {\n    let rowDiff = Math.max(0, endPos.row - startPos.row - 1);\n    this.text.splice(startPos + 1, rowDiff);\n\n    if (startPos.row === endPos.row) {\n      let colDiff = startPos.column - endPos.column;\n      this.text.splice(startPos.column, colDiff);\n    } else {\n      this.text.splice(startPos.column);\n      this.text.splice(0, endPos.column);\n    }\n  }\n\n  deleteChar(character) {\n    let _this$getPosOfChar2 = this.getPosOfChar(character),\n        row = _this$getPosOfChar2.row,\n        column = _this$getPosOfChar2.column;\n\n    if (character.value === '\\n') {\n      let nextLine = this.text[row + 1];\n      this.text.splice(row + 1, 1);\n      this.text[row] = this.text[row].concat(nextLine);\n    }\n\n    this.text[row].splice(column, 1);\n  }\n\n  getLeftChar(row, column) {\n    if (row === 0 && column === 0) {\n      return [];\n    }\n\n    row -= column === 0 ? 1 : 0;\n    return this.text[row][column];\n  }\n\n  getRightChar(row, column) {\n    let numRows = this.text.length;\n    let numCols = this.text[row].length;\n\n    if (row >= numRows - 1) {\n      //created a newline at EOF\n      return [];\n    } else if (column === numCols) {\n      //if inserted char is at EOL\n      if (row === numRows) {\n        return [];\n      } else {\n        row += 1;\n        column = 0;\n      }\n    }\n\n    return this.text[row][column].relativeIndex;\n  }\n\n  getPosOfChar(char) {\n    let row = binarySearchText(this.text, char, (arrayVal, val) => {\n      if (arrayVal.length === 0) {\n        return 0;\n      }\n\n      return arrayVal[0].greaterThan(char) ? 1 : arrayVal[arrayVal.length - 1].greaterThan(char) ? -1 : 0;\n    });\n    let column = binarySearchText(this.text[row], char, (arrayVal, val) => arrayVal.equalTo(val) ? 0 : arrayVal.greaterThan(val) ? 1 : -1);\n    return {\n      row,\n      column\n    };\n  }\n\n}\n\nexport default TextDocument;","map":{"version":3,"sources":["/Users/Jayson/Desktop/code-share/client/src/components/textdocument.js"],"names":["binarySearchText","TextDocument","constructor","text","getString","map","line","char","value","join","getChar","row","column","insertChar","character","getPosOfChar","newLine","splice","deleteChars","startPos","endPos","rowDiff","Math","max","colDiff","deleteChar","nextLine","concat","getLeftChar","getRightChar","numRows","length","numCols","relativeIndex","arrayVal","val","greaterThan","equalTo"],"mappings":"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","sourcesContent":["import { binarySearchText } from \"./utils\"\n\nclass TextDocument {\n\n  constructor() {\n    this.text = [[]]\n  }\n\n  getString() {\n    return this.text.map(line => line.map(char => char.value).join(\"\")).join(\"\")\n  }\n\n  getChar(row, column) {\n    return this.text[row][column]\n  }\n\n  insertChar(character) {\n    let { row, column } = this.getPosOfChar(character)\n    if (character.value === '\\n') {\n      let newLine = this.text[row].splice(column)\n      this.text.splice(row, 0, newLine)\n    }\n    this.text[row].splice(column, 0, character)\n  }\n\n  deleteChars(startPos, endPos) {\n    let rowDiff = Math.max(0, endPos.row - startPos.row - 1)\n    this.text.splice(startPos + 1, rowDiff)\n    if (startPos.row === endPos.row) {\n      let colDiff = startPos.column - endPos.column\n      this.text.splice(startPos.column, colDiff)\n    } else {\n      this.text.splice(startPos.column)\n      this.text.splice(0, endPos.column)\n    }\n  }\n\n  deleteChar(character) {\n    let { row, column } = this.getPosOfChar(character)\n    if (character.value === '\\n') {\n      let nextLine = this.text[row+1]\n      this.text.splice(row+1, 1)\n      this.text[row] = this.text[row].concat(nextLine)\n    }\n    this.text[row].splice(column, 1)\n  }\n\n  getLeftChar(row, column) {\n    if (row === 0 && column === 0) {\n      return []\n    }\n    row -= column === 0 ? 1 : 0\n    return this.text[row][column]\n  }\n\n  getRightChar(row, column) {\n    let numRows = this.text.length\n    let numCols = this.text[row].length\n    if (row >= numRows-1) { //created a newline at EOF\n      return []\n    } else if (column === numCols) { //if inserted char is at EOL\n      if (row === numRows) {\n        return []\n      } else {\n        row += 1\n        column = 0\n      }\n    }\n    return this.text[row][column].relativeIndex\n  }\n\n  getPosOfChar(char) {\n    let row = binarySearchText(this.text, char, (arrayVal, val) => {\n      if (arrayVal.length === 0) {\n        return 0\n      }\n      return arrayVal[0].greaterThan(char) ? 1 : arrayVal[arrayVal.length-1].greaterThan(char) ? -1 : 0\n    })\n    let column = binarySearchText(this.text[row], char, (arrayVal, val) => (\n      arrayVal.equalTo(val) ? 0 : arrayVal.greaterThan(val) ? 1 : -1\n    ))\n    return { row, column }\n  }\n}\n\nexport default TextDocument\n"]},"metadata":{},"sourceType":"module"}