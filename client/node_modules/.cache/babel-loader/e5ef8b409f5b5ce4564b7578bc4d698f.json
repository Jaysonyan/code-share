{"ast":null,"code":"const Character = import(\"./character\");\n\nconst _ref = import(\"./utils\"),\n      binarySearchText = _ref.binarySearchText;\n\nclass Document {\n  constructor() {\n    this.text = [[]];\n  }\n\n  getString() {\n    return this.text.map(line => line.map(char => char.val).concat(\"\")).concat(\"\");\n  }\n\n  getChar(row, column) {\n    return this.text[row][column];\n  }\n\n  insertChar(character) {\n    let _this$getPosOfChar = this.getPosOfChar(character),\n        row = _this$getPosOfChar.row,\n        column = _this$getPosOfChar.column;\n\n    if (character.value === '\\n') {\n      let newLine = this.text[row].splice(column);\n      this.text.splice(row, 0, newLine);\n    }\n\n    this.text[row].splice(column, 0, character);\n  }\n\n  deleteChars(startPos, endPos) {\n    let rowDiff = Math.max(0, endPos.row - startPos.row - 1);\n    this.text.splice(startPos + 1, rowDiff);\n\n    if (startPos.row === endPos.row) {\n      let colDiff = startPos.column - endPos.column;\n      this.text.splice(startPos.column, colDiff);\n    } else {\n      this.text.splice(startPos.column);\n      this.text.splice(0, endPos.column);\n    }\n  }\n\n  deleteChar(character) {\n    let _this$getPosOfChar2 = this.getPosOfChar(character),\n        row = _this$getPosOfChar2.row,\n        column = _this$getPosOfChar2.column;\n\n    if (character.value === '\\n') {\n      let nextLine = this.text[row + 1];\n      this.text.splice(row + 1, 1);\n      this.text[row] = this.text[row].concat(nextLine);\n    }\n\n    this.text[row].splice(column, 1);\n  }\n\n  getLeftChar({\n    row,\n    column\n  }) {\n    if (row === 0 && column === 0) {\n      return [];\n    }\n\n    row -= column === 0 ? 1 : 0;\n    return this.text[row][column];\n  }\n\n  getRightChar({\n    row,\n    column\n  }) {\n    let numRows = this.text.length;\n    let numCols = this.text[row].length;\n\n    if (row > numRows) {\n      //created a newline at EOF\n      return [];\n    } else if (column === numCols) {\n      //if inserted char is at EOL\n      if (row === numRows) {\n        return [];\n      } else {\n        row += 1;\n        column = 0;\n      }\n    }\n\n    return this.text[row][column].relativeIndex;\n  }\n\n  getPosOfChar(char) {\n    let row = binarySearchText(this.text, char, (arrayVal, val) => {\n      if (arrayVal.length === 0) {\n        return 0;\n      }\n\n      return arrayVal[0].greaterThan(char) ? 1 : arrayVal[arrayVal.length - 1].greaterThan(char) ? -1 : 0;\n    });\n    let column = binarySearchText(this.text[row], char, (arrayVal, val) => arrayVal.equalTo(val) ? 0 : arrayVal.greaterThan(val) ? 1 : -1);\n    return {\n      row,\n      column\n    };\n  }\n\n}\n\nexport default Document;","map":{"version":3,"sources":["/Users/Jayson/Desktop/code-share/client/src/components/document.js"],"names":["Character","binarySearchText","Document","constructor","text","getString","map","line","char","val","concat","getChar","row","column","insertChar","character","getPosOfChar","value","newLine","splice","deleteChars","startPos","endPos","rowDiff","Math","max","colDiff","deleteChar","nextLine","getLeftChar","getRightChar","numRows","length","numCols","relativeIndex","arrayVal","greaterThan","equalTo"],"mappings":"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","sourcesContent":["const Character = import(\"./character\")\nconst { binarySearchText } = import(\"./utils\")\nclass Document {\n  constructor() {\n    this.text = [[]]\n  }\n\n  getString() {\n    return this.text.map(line => line.map(char => char.val).concat(\"\")).concat(\"\")\n  }\n\n  getChar(row, column) {\n    return this.text[row][column]\n  }\n\n  insertChar(character) {\n    let { row, column } = this.getPosOfChar(character)\n    if (character.value === '\\n') {\n      let newLine = this.text[row].splice(column)\n      this.text.splice(row, 0, newLine)\n    }\n    this.text[row].splice(column, 0, character)\n  }\n\n  deleteChars(startPos, endPos) {\n    let rowDiff = Math.max(0, endPos.row - startPos.row - 1)\n    this.text.splice(startPos + 1, rowDiff)\n    if (startPos.row === endPos.row) {\n      let colDiff = startPos.column - endPos.column\n      this.text.splice(startPos.column, colDiff)\n    } else {\n      this.text.splice(startPos.column)\n      this.text.splice(0, endPos.column)\n    }\n  }\n\n  deleteChar(character) {\n    let { row, column } = this.getPosOfChar(character)\n    if (character.value === '\\n') {\n      let nextLine = this.text[row+1]\n      this.text.splice(row+1, 1)\n      this.text[row] = this.text[row].concat(nextLine)\n    }\n    this.text[row].splice(column, 1)\n  }\n\n  getLeftChar({row, column}) {\n    if (row === 0 && column === 0) {\n      return []\n    }\n    row -= column === 0 ? 1 : 0\n    return this.text[row][column]\n  }\n\n  getRightChar({row, column}) {\n    let numRows = this.text.length\n    let numCols = this.text[row].length\n    if (row > numRows) { //created a newline at EOF\n      return []\n    } else if (column === numCols) { //if inserted char is at EOL\n      if (row === numRows) {\n        return []\n      } else {\n        row += 1\n        column = 0\n      }\n    }\n    return this.text[row][column].relativeIndex\n  }\n\n  getPosOfChar(char) {\n    let row = binarySearchText(this.text, char, (arrayVal, val) => {\n      if (arrayVal.length === 0) {\n        return 0\n      }\n      return arrayVal[0].greaterThan(char) ? 1 : arrayVal[arrayVal.length-1].greaterThan(char) ? -1 : 0\n    })\n    let column = binarySearchText(this.text[row], char, (arrayVal, val) => (\n      arrayVal.equalTo(val) ? 0 : arrayVal.greaterThan(val) ? 1 : -1\n    ))\n    return { row, column }\n  }\n}\n\nexport default Document\n"]},"metadata":{},"sourceType":"module"}